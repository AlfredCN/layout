//  Copyright Â© 2017 Schibsted. All rights reserved.

import Foundation

/// An enumeration of the types of error that may be thrown by LayoutTool
enum FormatError: Error, CustomStringConvertible {
    case reading(String)
    case writing(String)
    case parsing(String)
    case options(String)

    public var description: String {
        switch self {
        case let .reading(string),
             let .writing(string),
             let .parsing(string),
             let .options(string):
            return string
        }
    }
}

/// File enumeration options
struct FileOptions {
    public var followSymlinks: Bool
    public var supportedFileExtensions: [String]

    public init(followSymlinks: Bool = false,
                supportedFileExtensions: [String] = ["xml"]) {

        self.followSymlinks = followSymlinks
        self.supportedFileExtensions = supportedFileExtensions
    }
}

/// Enumerate all xml files at the specified location and (optionally) calculate an output file URL for each.
/// Ignores the file if any of the excluded file URLs is a prefix of the input file URL.
///
/// Files are enumerated concurrently. For convenience, the enumeration block returns a completion block, which
/// will be executed synchronously on the calling thread once enumeration is complete.
///
/// Errors may be thrown by either the enumeration block or the completion block, and are gathered into an
/// array and returned after enumeration is complete, along with any errors generated by the function itself.
/// Throwing an error from inside either block does *not* terminate the enumeration.
func enumerateFiles(withInputURL inputURL: URL,
                    excluding excludedURLs: [URL] = [],
                    outputURL: URL? = nil,
                    options: FileOptions = FileOptions(),
                    concurrent: Bool = true,
                    block: @escaping (URL, URL) throws -> () throws -> Void) -> [Error] {

    guard let resourceValues = try? inputURL.resourceValues(
        forKeys: Set([.isDirectoryKey, .isAliasFileKey, .isSymbolicLinkKey])) else {
        if FileManager.default.fileExists(atPath: inputURL.path) {
            return [FormatError.reading("failed to read attributes for \(inputURL.path)")]
        }
        return [FormatError.options("file not found at \(inputURL.path)")]
    }
    if !options.followSymlinks &&
        (resourceValues.isAliasFile == true || resourceValues.isSymbolicLink == true) {
        return [FormatError.options("symbolic link or alias was skipped: \(inputURL.path)")]
    }
    if resourceValues.isDirectory == false &&
        !options.supportedFileExtensions.contains(inputURL.pathExtension) {
        return [FormatError.options("unsupported file type: \(inputURL.path)")]
    }

    let group = DispatchGroup()
    var completionBlocks = [() throws -> Void]()
    let completionQueue = DispatchQueue(label: "swiftformat.enumeration")
    func onComplete(_ block: @escaping () throws -> Void) {
        completionQueue.async(group: group) {
            completionBlocks.append(block)
        }
    }

    let manager = FileManager.default
    let keys: [URLResourceKey] = [.isRegularFileKey, .isDirectoryKey, .isAliasFileKey, .isSymbolicLinkKey]
    let queue = concurrent ? DispatchQueue.global(qos: .userInitiated) : completionQueue

    func enumerate(inputURL: URL,
                   outputURL: URL?,
                   options: FileOptions,
                   block: @escaping (URL, URL) throws -> () throws -> Void) {

        for excludedURL in excludedURLs {
            if inputURL.absoluteString.hasPrefix(excludedURL.absoluteString) {
                return
            }
        }
        guard let resourceValues = try? inputURL.resourceValues(forKeys: Set(keys)) else {
            onComplete { throw FormatError.reading("failed to read attributes for \(inputURL.path)") }
            return
        }
        if resourceValues.isRegularFile == true {
            if options.supportedFileExtensions.contains(inputURL.pathExtension) {
                do {
                    onComplete(try block(inputURL, outputURL ?? inputURL))
                } catch {
                    onComplete { throw error }
                }
            }
        } else if resourceValues.isDirectory == true {
            guard let files = try? manager.contentsOfDirectory(
                at: inputURL, includingPropertiesForKeys: keys, options: .skipsHiddenFiles) else {
                onComplete { throw FormatError.reading("failed to read contents of directory at \(inputURL.path)") }
                return
            }
            for url in files {
                queue.async(group: group) {
                    let outputURL = outputURL.map {
                        URL(fileURLWithPath: $0.path + url.path.substring(from: inputURL.path.characters.endIndex))
                    }
                    enumerate(inputURL: url, outputURL: outputURL, options: options, block: block)
                }
            }
        } else if options.followSymlinks &&
            (resourceValues.isSymbolicLink == true || resourceValues.isAliasFile == true) {
            let resolvedURL = inputURL.resolvingSymlinksInPath()
            enumerate(inputURL: resolvedURL, outputURL: outputURL, options: options, block: block)
        }
    }

    queue.async(group: group) {
        if !manager.fileExists(atPath: inputURL.path) {
            onComplete { throw FormatError.options("file not found at \(inputURL.path)") }
            return
        }
        enumerate(inputURL: inputURL, outputURL: outputURL, options: options, block: block)
    }
    group.wait()

    var errors = [Error]()
    for block in completionBlocks {
        do {
            try block()
        } catch {
            errors.append(error)
        }
    }
    return errors
}

func expandPath(_ path: String) -> URL {
    let path = NSString(string: path).expandingTildeInPath
    let directoryURL = URL(fileURLWithPath: FileManager.default.currentDirectoryPath)
    return URL(fileURLWithPath: path, relativeTo: directoryURL)
}

func list(_ files: [String]) -> [Error] {
    var errors = [Error]()
    for path in files {
        let url = expandPath(path)
        errors += enumerateFiles(withInputURL: url, concurrent: false) { inputURL, _ in
            do {
                let data = try Data(contentsOf: inputURL)
                if isLayout(data) {
                    return { _ in
                        var path = inputURL.path
                        if path.hasPrefix(url.path) {
                            path = path.substring(from: url.path.endIndex)
                        }
                        print("\(path)")
                    }
                }
                return { _ in }
            } catch {
                return {
                    throw error
                }
            }
        }
    }
    return errors
}
